# Parameters with Defaults
Functional options for friendly APIs

Chris Joyce
9 October 2022
chris@joyce.id.au

## Introduction

Go does not support function parameters with default values if unspecified.

Specifically, we want that

- Passing multiple parameters is supported.
- Interface remains backward-compatible when the number of type of one or more parameter changes.
- Parameters have default values that can be overridden.

In search of a general and elegant solution to this problem, I'll present a few straw-man approaches as motivations for you to think about functional options and **`With*()`** pattern.

: (After first paragraph)
: I want to begin my talk with a story.
: Your company is launching a revolutionary new distributed service.
: As don't understand yet the full requirements of this service, the first set of requirements are very limited.
: You have been tasked with writing the crucial service component. Possibly it looks a little like this.

## Strawman

.code _talk/strawman.go

: There are some unexported fields that need to be initialised, and a goroutine must be started to service incoming requests.
: The package has a simple API, it is pretty easy to use.
: But, there is a problem.
: Soon after you announce your first beta release, the feature requests start to roll in.


## Features, features, features

- "slow clients ....."
- "dose you server support TLS?"
- "can I limit ...."
- "I'm being DOS'd .."
- _...and more..._

: Mobile clients are often slow to respond, or stop responding altogether
: In this climate of heightened security awareness, your bug tracker starts to fill with demands to support secure connections
: You get a report from a user who is running your server on a very small VPS. They need a way to limit the number of simultaneous clients
: Next is the request to rate limit concurrent connections from a group of users being targeted by a botnet
: Now, you need to change your API to incorporate all these feature requests


## An improved API, maybe

.code _talk/improved.go /START OMIT/,/END OMIT/

Lets just add more fields to  **`NewServer`** and therefore to change the constructor into

Not only is this function incompatible with existing calls, it also becomes less readable as we add more parameters.


: Show of hands, who has used an API like this ?
: Who has written an API like this ?
: Who has had their code break while depending on an API like this ?

: Obviously this solution is cumbersome and brittle. It also isn’t very discoverable.
: Newcomers to your package have no idea which parameters are optional, and which are mandatory.


## But what if ?

I want to create an instance of the Server for testing, do I need to provide a real TLS certificate ?

.code _talk/tls.go /START OMIT/,/END OMIT/

I don’t care about maxconns, or maxconcurrent what value should I use ?

.code _talk/max.go /START OMIT/,/END OMIT/

: I don't need a cert, what do I provide instead ? .. nil maybe ?
: I don’t care about maxconns, or maxconcurrent
: Do I use zero ? Zero sounds reasonable, but depending on how the feature was implemented, that might limit you to zero total concurrent connections.
: It appears to me, that writing an API like this can be easy; as long as you make it the caller’s responsibility to use it correctly.
: So now that I’ve defined the problem, lets look at some solutions.

## Many functions make light work

.code _talk/manyfunctions.go /START OMIT/,/END OMIT/

Rather than trying to provide one single function which must cater for every permutation, a solution might be to create a set of functions.

_but_ it also means the total number of functions grows exponentially (power of 2) with the number of parameters, since each parameter could be included or excluded in a function.

: With this approach, when callers need a secure server they can call the TLS variant.
: When they need to establish a maximum duration for idle connections, they can use the variant that takes a timeout.
: Unfortunately, as you can see, providing every possible permutation can quickly become overwhelming.
: Let’s move on to others way of making your API configurable.

## Putting all params in a struct

.code _talk/configstruct.go /START OMIT/,/END OMIT/

Using this approach, the configuration struct can grow over time as new options are added, while the public API for creating a server itself remains unchanged.

Potentially it also enables the callers to use the zero value to signify they they want the default behaviour for a particular configuration option.

: A very common solution is to use a configuration struct.
: This has some advantages.
: This method can lead to better documentation.
: What was once a massive comment block on the NewServer function, becomes a nicely documented struct.

## Limited options

.code _talk/limited.go /START OMIT/,/END OMIT/

It has trouble with defaults, especially if the zero value has a well understood meaning.

For example, in the config structure shown here, when Port is not provided, NewServer will return a *Server for listening on port 8080.

: However, this pattern is not perfect.
: But this has the downside that you can no longer explicitly set Port to 0 and have the operating system automatically choose a free port, because that explicit 0 is indistinguishable from the fields’ zero value.

## Passing a struct pointer
.code _talk/structpointer.go /START OMIT/,/END OMIT/

The **`nil`** pointer is a good way distinguish set vs unset.

: However, The new problem is that either all fields need to use the default values or none of them does.
: Hence, if the user only wants to overwrite one parameter and use defaults for the rest, the user must supply the default values for other fields explicitly. Yikes.

## Make all fields pointers

.code _talk/allpointers.go  /START OMIT/,/END OMIT/

Since the  **`nil`** pointer is a good way distinguish set vs unset, making all the fields a pointer seems to do the trick.

In Go there is no such thing as **`&20`** or **`&"hello"`**

.code _talk/allpointersset.go  /START OMIT/,/END OMIT/

: However, this is not user-friendly at all,
: Because in Go there is no such thing as **`&20`** or **`&"hello"`** and the call must assign the literal value to a temporary variable and then take its address.
: Not pretty.


## "I just want a server, I don't want to have to think about it"

.code _talk/wantaserver.go /START OMIT/,/END OMIT/

Most of the time, users of your API will be expecting to use its default behaviour.

Even though they do not intend to change any of the configuration parameters, those callers are still required to pass something for that second argument.

: So, when people read your tests or your example code, trying to figure out how to use your package, they’ll see this magic empty value, and it’ll become enshrined in the collective unconsciousness.

: and to me, this just feels wrong.

: Why should users of your API be required to construct an empty value, simply to satisfy the signature of the function ?


## Maybe adding indirection will help

.code _talk/indirection.go /START OMIT/,/END OMIT/

A common solution to this empty value problem is to pass a pointer to the value instead, thereby enabling callers to use nil rather than constructing an empty value.

We still have to pass something for this function’s second argument, but now this value could be nil, and most of the time will be nil for those wanting the default behaviour.

More concerning to both the package’s author, and its callers, is the Server and the caller can now share a reference to the same configuration value. Which gives rise to questions of what happens if this value is mutated after being passed to the NewServer function ?


: In my opinion this pattern has all the problems of the previous example, and it adds a few more.
: It raises the question, is there a difference between passing nil, and passing a pointer to an empty value ?
: I believe that well written APIs should not require callers to create dummy values to satisfy those rarer use cases.
: I believe that we, as Go programmers, should work hard to ensure that nil is never a parameter that needs to be passed to any public function.

And when we do want to pass configuration information, it should be as self explanatory and as expressive as possible.

So now with these points in mind, I want to talk about what I believe are some better solutions.

## Variadic configuration

.code _talk/variadic.go  /START OMIT/,/END OMIT/

First, the default behaviour becomes as concise as possible.

Secondly, NewServer now only accepts Config values, not pointers to config values, removing nil as a possible argument, and ensuring that the caller cannot retain a reference to the server’s internal configuration.

Instead of passing nil, or some zero value, as a signal that you want the defaults, the variadic nature of the function means you don’t need to pass anything at all.

: To remove the problem of that mandatory, yet frequently unused, configuration value, we can change the NewServer function to accept a variable number of arguments.
: And in my book this solves two big problems.
: I think this is a big improvement.

## But it still has problems

Obviously the expectation is for you to provide at most one Config value.

But as the function signature is variadic, the implementation has to be written to cope with a caller passing multiple, possibly contradictory, configuration structs.

Is there a way to use a variadic function signature and improve the expressiveness of configuration parameters when needed ?

I think that there is.

At this point I want to make it clear that that the idea of functional options comes from a blog post titled.
*Self referential functions and design by Rob Pike* , published in January 2014.


## Functional Options

.code _talk/functional.go /START OMIT/,/END OMIT/

The key difference from the previous example, and in fact all the examples so far, is customisation of the Server is performed not with configuration parameters stored in a structure, but with functions which operate on the Server value itself.

: As before, the variadic nature of the function’s signature gives us the compact behaviour for the default case.
: When configuration is required, we pass to NewServer functions which operate on the Server value as an argument.
: The timeout function simply changes the timeout field of any *Server value passed to it.
: maxconns as well

## Functional Options In the API

.code _talk/functional_cont.go /START OMIT/,/END OMIT/

Inside NewServer, applying these options is straightforward.

After opening a net.Listener, we declare a Server instance using that listener.

Then, for each option function provided to NewServer, we call that function, passing in a pointer to the Server value that was just declared.

: Obviously, if no option functions were provided, there is no work to do in this loop and so srv is unchanged.
: And that’s all there is too it.

## What dose this patten offer us ?

Using this pattern we can make an API that has

- sensible defaults
- is highly configurable
- can grow over time
- self documenting
- safe for newcomers
- and never requires nil or an empty value to keep the compiler happy

: In the few minutes I have remaining I’d like to show you how I to create your own packages by useing functional options.

## New strawman

.code strawman/strawman.go

## Options for example

.code strawman/options.go

## Options for example

.code strawman/hay.go

## Client code

.play -edit main.go

: Edit and run again